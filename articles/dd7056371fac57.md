---
title: "公式推奨のDockerfileの記述法とWebアプリ作成時のDockerfile作成例"
emoji: "🐳"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["Docker", "Dockerfile"]
published: true
published_at: 2025-05-06 09:00
---
## はじめに

<https://zenn.dev/wan0ri/articles/ee3a7dff1b368e>  

こちらの記事でDockerコマンドを使って起動・停止・状態確認・削除などをのコマンドを掲載しているが、いちいちコマンドを入力してDockerを扱うのは非常に面倒になってくる。

そこで、Dockerfileを使用してDockerの取り扱いを楽にしていく。
</br>

## 概要

### そもそもDockerfileとは？

- 特定の命令セットを記述することで、コンテナのビルド手順を定義するファイル
- 主に開発者が使用し、プロジェクトの依存関係や必要な設定を一元管理する
- これにより、チーム全体で一貫した環境を保つことができ、環境設定の手間を大幅に削減できる

### Dockerfileが重要な理由

Dockerfileは、コンテナの一貫性と再現性を保証する。
これにより、開発環境と本番環境の差異を減らし、デプロイの問題を軽減することができる。
Dockerfileを使用することで、環境構築が自動化され、人的ミスのリスクが減少する。

### Dockerfileの基本構成

Dockerfileの基本構成は、ベースイメージの指定から始まり、必要なファイルのコピー、パッケージのインストール、環境変数の設定などが含まれている。
これらの命令は、一つのファイルに順序立てて記述され、Dockerビルドプロセスで順に実行される。

### DockerfileとDockerイメージの関係

Dockerfileは、Dockerイメージを生成するための設計図。
Dockerfileに記述された命令に従って、Dockerイメージがビルドされ、そのイメージからコンテナが起動される。
イメージは、各ステップのスナップショットとして保存され、効率的な再利用が可能。

### Dockerfileの利用シーン

Dockerfileは、開発環境の構築やテストの自動化、CI/CDパイプラインの一部として使用される。
また、異なる環境間での移植性が高いため、チーム全体で統一された開発環境を提供することができる。
これにより、開発効率と品質が向上する。
</br>

## 記述方法

### 基本構文

Dockerfileは命令ベースで記述する。
代表的なもの：

`FROM`: ベースイメージ指定
`RUN`: コマンド実行（イメージ作成時）
`COPY / ADD`: ファイルやディレクトリをコピー
`WORKDIR`: 作業ディレクトリ設定
`CMD`: コンテナ起動時のデフォルトコマンド
`ENTRYPOINT`: コンテナ起動時の実行バイナリ指定
`ENV`: 環境変数定義
`EXPOSE`: ポート公開
`VOLUME`: ボリューム定義

### ベストプラクティス

<https://docs.docker.com/develop/develop-images/dockerfile_best-practices/>  

Docker公式が推奨している順番に沿うとよい。
(企業様や使用者によりベストプラクティスが異なると思うが、了承願いたい。あくまで公式ベースということで…)
公式を読み取ると、以下の内容でまとめられている。

- 命令の順序についての推奨事項
- イメージのキャッシュ利用とビルド効率
- イメージサイズを小さくする方法
- レイヤーの最適化
- セキュリティの考慮

これを考慮すると、順番としては以下に収まっていく。

`FROM`: ベースイメージ指定
`LABEL`: バージョン、作者などのメタ情報
`ENV`: 環境変数定義
`WORKDIR`: 作業ディレクトリ設定
`COPY / ADD`: ファイルやディレクトリをコピー
`RUN`: コマンド実行（イメージ作成時）
`EXPOSE`: ポート公開
`VOLUME`: ボリューム定義
`ENTRYPOINT / CMD`: コンテナ起動時の実行バイナリ指定、コンテナ起動時のデフォルトコマンド

💡キャッシュを活用するため、変更頻度が少ないものほど先に書くとよい。

### サイズを小さくするコツ

- 軽量ベースイメージを使う：
  - 例: alpine, debian:slim
- 不要なファイルをCOPYしない：
  - `.dockerignore`を活用
- マルチステージビルド：
  - ビルド専用と実行専用で**イメージを分ける**
- RUNをまとめる：
  - レイヤーを減らすために`&&`で結合
- キャッシュ削除：
  - `apk add ... && rm -rf /var/cache/apk/\*`
   ※Alpineの場合

</br>

## 記述例

### 構成パターン

1. Reactアプリ（静的ファイルをビルド）
通常、npm run buildでbuild/ディレクトリが作られ、それをNginxなどで配信するかRailsのpublic/フォルダに置く。
2. Railsアプリ
必要最小限のライブラリだけインストールし、開発用パッケージやキャッシュは削除。

### Dockerfileを分ける or 1つにまとめる？

- **開発時は分けた方が良い** （Docker Composeなどでフロント・バックを別コンテナにする）。
- 本番では、Railsが静的ファイルを配信するなら1つのイメージにまとめてもOK。

ここでは 1つにまとめる場合の例を記載する。

### 実践的なDockerfile例（マルチステージ）

**●details Dockerfileを1つにまとめた例**  

```bash
# ===== フロントエンドビルドステージ =====
FROM node:20-alpine AS frontend-build

WORKDIR /app/frontend

# package.jsonだけ先にCOPYしてキャッシュ活用
COPY frontend/package*.json ./

RUN npm ci

COPY frontend/ ./

RUN npm run build


# ===== バックエンドビルドステージ =====
FROM ruby:3.2-alpine AS backend-build

# OSパッケージインストール（例: PostgreSQL対応の場合）
RUN apk add --no-cache build-base postgresql-dev nodejs yarn

WORKDIR /app

# Gemfileだけ先にCOPYしてキャッシュ活用
COPY backend/Gemfile backend/Gemfile.lock ./

# bundle install（--without development testで容量削減）
RUN bundle install --without development test

# アプリケーション全体をCOPY
COPY backend/ ./

# ===== 本番実行ステージ =====
FROM ruby:3.2-alpine

# OSパッケージ（最小限）
RUN apk add --no-cache postgresql-client

WORKDIR /app

# バンドル済みgemsをCOPY
COPY --from=backend-build /usr/local/bundle /usr/local/bundle

# アプリをCOPY
COPY --from=backend-build /app /app

# フロントエンドビルド成果物をpublic/に配置
COPY --from=frontend-build /app/frontend/build /app/public

# 環境変数やポート
ENV RAILS_ENV=production
EXPOSE 3000

CMD ["rails", "server", "-b", "0.0.0.0"]
```

### .dockerignore（容量削減の大事なポイント）

RailsとReactそれぞれに必須：

**●details .dockerignore**  

```bash
# 共通
node_modules
log
tmp
.git
.dockerignore

# Rails特有
vendor/bundle
coverage
public/assets
public/packs

# React特有
build
```

### Dockerfileの意識ポイント

1. マルチステージで最終イメージにはフロントの `build` だけが入る。
2. COPY順序を意識してキャッシュが効きやすく。
3. node_modulesやvendor/bundleは **.dockerignore** で除外。
4. 不要な開発ツールは最終イメージに含めない：

- apk addなども最終段階では最小限。
- bundle install --without development testでサイズ最適化。

### 補足

- **Nginx併用**：
RailsではなくNginxを使ってフロントエンドを配信したい場合は、Nginx用Dockerfileも作成してReactのbuildディレクトリを/usr/share/nginx/htmlに置くのが一般的。
- **Docker Compose併用**：
フロント・バックを別々に動かすならdocker-compose.ymlでサービスを分けて管理したほうが、開発中は便利。

</br>

👷‍♂️docker-composeは近日中にまとめるのでしばしお待ちを。
